---
title: "Hands-on Exercise 1.1: Geospatial Data Wrangling with R"
author: "Yu Tang Hsieh"
---

Getting Started Install and launching R packages

The code chunk below is installed in the R environment.

```{r}
pacman::p_load(sf,tidyverse)
```

Imported Geospatial Data

1.  Import polygon feature data in shapefile format

st_read() function of sf package:

imports MP14_SUBZONE_WEB_PL shapefile into R as polygon feature data frame

dsn = defines data path; layer = provide the shapefile name

```{r}
mpsz = st_read("C:/ythsieh14/ISSS626-GAA/Hands-on-Ex/Hands-on_Ex01/data/geospatial/MasterPlan2014SubzoneBoundaryWebSHP"              ,layer = "MP14_SUBZONE_WEB_PL")
```

2.  Import polyline feature data in shapefile form

```{r}
  cyclingpath = st_read(dsn = "C:/ythsieh14/ISSS626-GAA/Hands-on-Ex/Hands-on_Ex01/data/geospatial/CyclingPath_Jul2024",                      layer = "CyclingPathGazette")
```

3.  Import GIS data in kml format

```{r}
preschool = st_read("C:/ythsieh14/ISSS626-GAA/Hands-on-Ex/Hands-on_Ex01/data/geospatial/PreSchoolsLocation.kml")
```

Checking the Content of A Simple Feature Data Frame

1.  st_geometry()

```{r}
st_geometry(mpsz)
```

2.  glimpse() shows datatype of each field

```{r}
glimpse(mpsz)
```

3.  head() display the data table

```{r}
head(mpsz,n=5)
```

Plotting the Geospatial Data

plot() visualises geospatial features

```{r}
plot(mpsz)
```

If we only want to plot the geometry, can use the code below

```{r}
plot(st_geometry(mpsz))
```

Alternatively, we can also choose the plot the sf object by using a specific attribute as shown in the code chunk below.

```{r}
plot(mpsz["PLN_AREA_N"])
```

Working with Projection

projection transformation is to project a simple feature data frame from one coordinate system to another coordinate system.

Assigning EPSG code to a simple feature data frame

When importing geospatial data into R, the coordinate system may be missing or incorrectly assigned. This is when we can check the coordinate system of a simple feature data frame using st_crs() from the sf package.

```{r}
st_crs(mpsz)
```

Although mpsz data frame is projected in svy21 but EPSG is indicated as 9001. Correct EPSG code should be 3414.

In order to assign the correct EPSG code to mpsz data frame, st_set_crs() of sf package is used

```{r}
mpsz3414 <- st_set_crs(mpsz, 3414)
```

use CSR again to check and will found out that EPSG code is now 3414

```{r}
st_crs(mpsz3414)
```

Transforming the projection of preschool from wgs84 to svy21

In geospatial analytics, the preschool simple feature data frame is currently in the WGS84 geographic coordinate system, which uses latitude and longitude. For analyses involving distance or area measurements, it would be more appropriate to transform this data into a projected coordinate system.

```{r}
preschool = st_read("data/geospatial/PreSchoolsLocation.kml")
```

This is a scenario that st_set_crs() is not appropriate and st_transform() of sf package should be used. This is because we need to reproject preschool from one coordinate system to another coordinate system mathemetically.

Perform the projection transformation by using the code chunk below

```{r}
preschool3414 <- st_transform(preschool, crs = 3414)
```

Display the content of preschool3414 sf data frame

```{r}
head(preschool3414, n=5)
```

Importing and Converting An Aspatial Data

Data like the Airbnb listings are referred to as aspatial data because, while not inherently geospatial, they include fields with x- and y-coordinates for each data point. We will learn how to import this aspatial data into the R environment, save it as a tibble data frame, and then convert it into a simple feature data frame.

Importing the aspatial data

Since listings data set is in csv file format, we will use read_csv() of readr package to import listing.csv as shown the code chunk below. The output R object is called listings

```{r}
listings <- read_csv("C:/ythsieh14/ISSS626-GAA/Hands-on-Ex/Hands-on_Ex01/data/aspatial/listings.csv")
```

After importing the data file into R, it is important for us to examine if the data file has been imported correctly using the below code chunk.

```{r}
list(listings) 
```

Main takeaway: The output reveals that listing tibble data frame consists of 3540 rows and 18 columns. Two useful fields we are going to use in the next phase are latitude and longitude and are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.

Creating a simple feature data frame from an aspatial data frame The code chunk below converts listing data frame into a simple feature data frame by using st_as_sf() of sf packages

```{r}
listings_sf <- st_as_sf(listings, 
                       coords = c("longitude", "latitude"),
                       crs=4326) %>%
  st_transform(crs = 3414)
```

coords: requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates. crs: requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other countryâ€™s epsg code by referring to epsg.io. %\>% : nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system

Let us examine the content of this newly created simple feature data frame.

```{r}
glimpse(listings_sf)
```

Table above shows the content of listing_sf. Notice that a new column called geometry has been added into the data frame. On the other hand, the longitude and latitude columns have been dropped from the data frame.

Geoprocessing with sf package

Besides providing functions to handling (i.e. importing, exporting, assigning projection, transforming projection etc) geospatial data, sf package also offers a wide range of geoprocessing (also known as GIS analysis) functions. We will learn how to perform two commonly used geoprocessing functions, namely buffering and point in polygon count.

Buffering

Scenario: The authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.

Solution: 1.st_buffer() of sf package is used to compute the 5-meter buffers around cycling paths

```{r}
buffer_cycling <- st_buffer(cyclingpath, 
                               dist=5, nQuadSegs = 30)
```

2.Calculating the area of the buffers as shown in the code chunk below.

```{r}
buffer_cycling$AREA <- st_area(buffer_cycling)
```

3.sum() of Base R will be used to derive the total land involved

```{r}
sum(buffer_cycling$AREA)
```

Point-in-polygon count

Scenario: A pre-school service group want to find out the numbers of pre-schools in each Planning Subzone

Solution: 1. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.

```{r}
mpsz3414$`PreSch Count`<- lengths(st_intersects(mpsz3414, preschool3414))
```

2.  Check summary statistics of the newly derived PreSch Count field by using summary().

```{r}
summary(mpsz3414$`PreSch Count`)
```

3.  To list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used.

```{r}
top_n(mpsz3414, 1, `PreSch Count`)
```

Scenario: Calculate the density of pre-school by planning subzone.

Solution:

1.Use st_area() of sf package to derive the area of each planning subzone

```{r}
mpsz3414$Area <- mpsz3414 %>% st_area()
```

2.mutate() of dplyr package is used to compute the density

```{r}
mpsz3414 <- mpsz3414 %>% mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)

print(mpsz3414)
```

Exploratory Data Analysis (EDA)

Many geospatial analytics start with Exploratory Data Analysis. We will learn how to use appropriate ggplot2 functions to create functional and yet truthful statistical graphs for EDA purposes.

Plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used.

```{r}
hist(mpsz3414$`PreSch Density`)
```

Although syntax is easy, the output is far from meeting publication quality. Function also has limited room for further customization.

```{r}
ggplot(data=mpsz3414,
       aes(x=as.numeric(`PreSch Density`)))+
  geom_histogram(bins=20,
                 color="black",
                 fill="light blue") +
  labs(title= "Are pre-schools evenly distributed in Singapore?",
       subtitle = "There are may planning sub-zones with a single pre-school, on the other hand, \nthere are two planning sub-zones with at least 20 pre-schools.",
       x = "Pre-school density (per km sq)",
       y = "Frequency")
```

Using ggplot2 method, we can also plot a scatterplot showing the relationship between pre-school density and pre-school count.

```{r}
ggplot(data=mpsz3414,
       aes(y = `PreSch Count`,
           x=as.numeric(`PreSch Density`)))+
  geom_point(color="black",
             fill="light blue") +
  xlim(0, 40) +
  ylim(0, 40) +
  labs(title= "",
       x = "Pre-school density (per km sq)",
       y = "Pre-school count")
```
